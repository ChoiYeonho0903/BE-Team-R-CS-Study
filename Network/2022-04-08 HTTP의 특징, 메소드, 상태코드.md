# 1. HTTP

HTTP는 HyperText Transfer Protocol의 약자로, 인터넷 상에서 클라이언트와 서버가 자원을 주고 받을 때 쓰는 통신 규약이다.

HTTP의 기반 프로토콜은 HTTP의 버전에 따라 다음과 같이 나뉜다.

| 프로토콜 | HTTP |
| --- | --- |
| TCP | HTTP/1.1, HTTP/2 |
| UDP | HTTP/3 |

현재는 HTTP/1.1을 주로 사용하지만 HTTP/2, HTTP/3도 점점 증가하는 추세이다.

HTTP/2, HTTP/3은 HTTP/1.1을 기반으로 성능 개선을 주로 한 버전이다.

<br>

## (1) HTTP 특징

### ① 클라이언트 서버 구조

- Request Response 구조
- 클라이언트는 서버에 요청을 보내고, 응답을 대기
- 서버는 요청에 대한 결과를 만들어서 응답
<br>

### ② 무상태 프로토콜 (Stateless)

- 서버가 클라이언트의 상태를 보존하지 않는다
- 장점 : 서버 확장성 높음 (Scale Out)
- 단점 : 클라이언트가 추가 데이터 전송해야 함

- 모든 것을 무상태로 설계할 수 있는 경우도 있고 없는 경우도 있다.
    - ex) 로그인의 경우 상태 유지가 필요하다.
    - 따라서, 상태 유지는 최소한으로만 사용한다.
<br>

<details close>
  <summary>Stateful vs Stateless</summary>
    
### 1. Stateful

stateful은 상태를 유지하는 경우를 말한다.

일상생활과 비교해서 이해를 해보자.


---

고객 : 이 책은 얼마인가요?

점원 : 만원 입니다.

고객 : 2권 구매하겠습니다

점원 : 2만원 입니다. 신용카드 현금 중에 어떤 걸로 결제하시겠어요?

고객 : 신용카드로 결제하겠습니다.

점원 : 2만원 결제 완료되었습니다.

---


이 경우를 보면 점원은 이 전에 고객이 물어본 내용들을 기억하고, 해당 내용들에 기반해서 다음 요청을 처리한다.

이런 경우에는 중간에 점원이 다른 점원으로 바뀌게 되면 기존 직원이 현재 고객의 상태를 다음 직원에게 전달해줘야한다.



### 2. Stateless

Stateless는 상태를 유지하지 않는 경우를 말한다.

이 또한 일상생활과 비교해서 이해를 해보자.


---

고객 : 이 책은 얼마인가요?

점원1 : 만원 입니다.

고객 : 2권 구매하겠습니다

점원2 : 무슨 책을 2권 구매하시겠어요?

고객 : 신용카드로 결제하겠습니다.

점원3 : 무슨 책을 몇 권 신용카드로 결제하시겠어요?

---


이 경우는 모든 점원들이 고객의 정보를 공유하고 있지 않기 때문에, 상태 정보를 저장하지 않는 Stateless한 경우라고 볼 수 있다.  해당 예시를 보면 Stateless이기 때문에 요청이 제대로 처리되지 않는 것을 볼 수 있다.

Stateless인 경우에 요청을 제대로 처리하기 위해서는 고객이 자신의 현재 상황을 점원에게 매번 전달해야한다.


---

고객 : 이 책은 얼마인가요?

점원1 : 만원 입니다.

고객 : ???이라는 책을 2권 구매하겠습니다.

점원2 : 2만원 입니다. 신용카드, 현금 중에 어떤 걸로 구매하시겠어요?

고객 : ???이라는 책을 2권, 신용카드로 구매하겠습니다.

점원3 : 2만원 결제 완료되었습니다.

---


따라서 Stateless인 경우에는 갑자기 고객이 증가해도 점원을 중간에 많이 투입할 수 있다.

→ 즉, 클라이언트 요청이 갑자기 증가해도 서버를 쉽게 증설할 수 있다.
  
  </details>
  
  <details>
  <summary>Scale Out vs Scale Up</summary>
    
### 1. Scale Out

Scale Out은 서버의 대수를 늘려 처리 능력을 향상시키는 것이다.

즉, 하나의 장비에서 처리하던 일을 여러 장비들이 나눠서 처리할 수 있도록 설계를 변경하는 것이다.

수평적으로 확장하기 때문에, 수평 스케일로 불리기도 하며, 지속적인 확장이 가능하다.

### 2. Scale Up

Scale Up은 현재 사용중인 서버 자체를 증강하여 처리 능력을 향상시키는 것이다.

더 빠른 속도의 CPU로 변경하거나, 더 많은 RAM을 추가하는 등 하드웨어 장비의 성능을 높이는 방법이다.

따라서 수직 확장이라고 하며, 성능 확장에 한계가 있다.

<figure>
  <img src = "https://user-images.githubusercontent.com/50768959/162284822-18a79fe7-dfc9-4300-8af5-ec298bea1575.png" width="500">
  <figcaption>
    출처 : https://m.blog.naver.com/islove8587/220548900044](https://m.blog.naver.com/islove8587/220548900044
  </figcaption>
</figure>

<br><br>
  


</details>
<br>

### ③ 비 연결성 (Connectionless)

- HTTP는 기본적으로 연결을 유지하지 않는 모델이다.
- 이를 통해 서버 자원을 매우 효율적으로 사용할 수 있다.
- 단점
- TCP/IP 연결을 새로 맺어야 한다 → 3 way handshake 시간 추가
- 웹 브라우저로 사이트를 요청하면 HTML + 수 많은 자원들이 다운로드 된다.
- 지금은 HTTP 지속 연결로 문제 해결


<figure>
  <img src = "https://user-images.githubusercontent.com/50768959/162283696-5ab69ca1-3407-4d02-aa32-19c18b0da527.png" width="700">
  <figcaption>
    <br><br>
    출처 :https://velog.io/@jeon9771/HTTP-HTTP-기본
  </figcaption>
</figure>

<br><br>

<details>
  <summary>HTTP 지속 연결 (HTTP Persistent Connections)</summary>
<br>
자원 하나를 요청했을 때, 이와 묶여있는 모든 자원을 요청하기 위해 연결을 유지한 상태

클라이언트는 서버에서 응답이 오기전에 자원을 연속적으로 요청할 수 있고, 서버는 파이프라이닝을 통해 연속적으로 응답할 수 있다.

이를 통해 연결 시도 횟수가 줄어들어 효율적이다.

- HTTP 1.0 : 지속 연결을 원할 시 , Keep-Alive를 헤더에 담아서 요청을 보낸다
- HTTP 1.1 : 명시되어있지 않으면 모든 연결은 지속연결로 간주된다. 각 서버마다 타임 아웃이 존재한다.
</details>

<br>

# 2. HTTP Method

request의 시작줄은 메서드로 시작하며, 서버에게 무엇을 해야 하는지 말해준다.

대표적으로 GET, HEAD, POST, PUT, PATCH, TRACE, OPTIONS, DELETE의 8가지가 있다.

<br>

### (1) GET

GET은 가장 흔히 쓰이는 메서드로 주로 서버에게 리소스를 달라고 요청하기 위해 사용한다.

서버에 전달하고 싶은 데이터는 query를 통해서 전달한다.

메세지 바디를 사용할 수는 있지만, 지원하지 않는 곳이 많다.

<figure>
  <img src = "https://user-images.githubusercontent.com/50768959/162285148-4b748d1d-f18d-4240-bfa6-cc08031795e2.png" width="500">
  <figcaption>
    출처 : https://medium.com/@lyhlg0201/http-method-d561b77df7
  </figcaption>
</figure>
<br><br>


<br>

### (2) POST

POST 메서드는 서버에 입력 데이터를 전송하기 위해 설계되었다. 실제로 HTML 폼을 지원하기 위해 흔히 사용된다.

클라이언트는 메시지 바디를 통해 서버로 요청 데이터를 전달한다.

서버는 요청 데이터를 처리하는데, 메시지 바디를 통해 들어온 데이터를 처리하는 모든 기능을 수행한다.

<사용하는 경우>

- 새 리소스 생성 : 서버가 아직 식별하지 않은 새 리소스 생성
- 요청 데이터 처리
    - 단순히 데이터를 생성하거나, 변경하는 것을 넘어서 프로세스를 처리하는 경우
    - ex) 결제완료 → 배달시작 → 배달 완료 처럼 프로세스의 상태가 변경되는 경우
    - POST의 결과로 새로운 리소스가 생성되지 않을 수도 있음
- 다른 메서드로 처리하기 애매한 경우

<figure>
  <img src = "https://user-images.githubusercontent.com/50768959/162285313-7e29f3f0-1d90-4dbb-8840-f84de9bb1231.png" width="500">
  <figcaption>
    출처 : https://medium.com/@lyhlg0201/http-method-d561b77df7
  </figcaption>
</figure>
<br><br>


<br>

### (3) PUT

PUT 메서드는 서버가 요청의 본문을 가지고 요청 URL의 이름대로 새 문서를 만들거나, 이미 URL이 존재한다면 본문을 사용해서 교체하는 것이다.

즉, 리소스가 있으면 대체하고 (덮어쓰고) 없으면 생성하는 것이다.

**POST와 달리 클라이언트가 리소스 위치를 알고 URI를 지정한다.**

중요한 것은, GET은 부분수정이 아니라는 점이다.

원래 서버에 다음과 같은 리소스가 있었다고 하자.

<br>

---

/members/100

{

“username” : “young”,

“age” : 20

}

---

<br>


그리고 클라이언트는 다음과 같은 body를 가진 PUT 요청을 /members/100에 보냈다.

---

{

“age” : 30

}

---

<br>


이 후, 클라이언트가 GET 요청을 통해 /members/100을 조회하면 다음과 같다.

---

{

“age” : 30

}

---

즉, 바뀐 속성만 수정하는 것이 아니라 아예 덮어쓰는 것이다.

<br>


### (4) PATCH

PATCH는 PUT 처럼 리소스를 변경하지만, PUT과 달리 부분 수정이 가능하다.

원래 서버에 다음과 같은 리소스가 있었다고 하자.

---

/members/100

{

“username” : “young”,

“age” : 20

}

---

<br>


그리고 클라이언트는 다음과 같은 body를 가진 PUT 요청을 /members/100에 보냈다.

---

{

“age” : 30

}

---

<br>

이 후, 클라이언트가 GET 요청을 통해 /members/100을 조회하면 다음과 같다.

---

{

“username” : “young”,

“age” : 30

}

<br>

### (5) DELETE

DELETE는 이름 그대로 서버에게 요청 URL로 지정한 리소스를 삭제할 것을 요청한다.

하지만 클라이언트는 삭제가 수행되는 것을 보장하지 못한다.

HTTP 명세는 서버가 클라이언트에게 알리지 않고 요청을 무시하는 것을 허용하기 때문에, 서버는 DELETE 요청을 받고도 삭제를 하지 않을 수 있는 것이다.

<figure>
  <img src = "https://user-images.githubusercontent.com/50768959/162285414-941625e5-9507-4d0b-9c0d-edfff7a11426.png" width="500">
  <figcaption>
    출처 : https://medium.com/@lyhlg0201/http-method-d561b77df7
  </figcaption>
</figure>
<br><br>

<br>


### (6) TRACE

TRACE 메서드는 클라이언트에게 자신의 요청이 서버에 도달했을 때, 어떻게 보이게 되는지 알ㄹ려준다. 따라서 주로 진단을 위해 사용된다.

클라이언트가 보낸 요청은 방화벽, 프록시 서버, 게이트 웨이 등을 거치면서 메세지가 망가지거나 수정될 수 있다. 이 때, TRACE를 사용하면 서버에 도착한 최종 메시지가 어떻게 변경 되었는지 확인할 수 있다.

<figure>
  <img src = "https://user-images.githubusercontent.com/50768959/162285519-e9b08c4b-bb0d-49b0-9016-41d5c23b437f.png" width="500">
  <figcaption>
    출처 : https://medium.com/@lyhlg0201/http-method-d561b77df7
  </figcaption>
</figure>
<br><br>

<br>


### (7) OPTIONS

OPTIONS 메서드를 통해 클라이언트는 서버에게 특정 리소스에 대해 어떤 메서드가 지원되는지 물어볼 수 있다.

<figure>
  <img src = "https://user-images.githubusercontent.com/50768959/162285618-c2a6446d-e6f7-42af-9c20-6494e00875fd.png" width="500">
  <figcaption>
    출처 : https://medium.com/@lyhlg0201/http-method-d561b77df7
  </figcaption>
</figure>
<br><br>

<br>


### (8) HEAD

HEAD 메서드는 GET처럼 행동하지만, 서버는 응답으로 헤더만 돌려준다.

이를 통해 클라이언트는 다음과 같은 것을 알아낼 수 있다.

- 리소스를 가져오지 않고도, 리소스의 타입 등을 알아낼 수 있다.
- 응답의 상태 코드를 통해, 개체가 존재하는지 확인할 수 있다.
- 헤더를 확인하여 리소스가 변경되었는지 검사할 수 있다.

서버 개발자는 반드시 HEAD 메서드에 반환되는 헤더가 GET으로 얻는 것과 정확히 일치함을 보장해야하며, HTTP/1.1 준수를 위해서는 HEAD 메서드가 반드시 구현되어 있어야 한다.

<br>


# 3. HTTP Method 특징

<figure>
  <img src = "https://user-images.githubusercontent.com/50768959/162285731-74134104-773e-4649-9075-b811453c60a7.png" width="700">
  <figcaption>
    출처 : https://velog.io/@hb-developer/HTTP-메서드
  </figcaption>
</figure>
<br><br>


HTTP 메서드들은 위와 같은 특징을 갖는다.

<br>

### (1) 안전 (Safe)

- 안전하다는 의미는 호출해도 리소스를 변경하지 않는다는 의미이다
- 우리가 GET 메서드를 서버에 날리다고 서버의 리소스가 변경되지는 않는다.

<br>


### (2) 멱등 (Idempotent)

- 멱등은 한 번 호출하든 두 번 호출하든 100번 호출하든 결과가 똑같다는 의미이다.
- GET : 한 번 조회하든, 두 번 조회하든 같은 결과가 조회된다.
- PUT : 결과를 대체하기 때문에, 같은 요청을 여러번 해도 최종 결과는 같다.
- DELETE : 결과를 삭제하기 때문에, 같은 요청을 여러번 해도 삭제된 결과는 똑같다.
- **POST : 두 번 호출하면 같은 결제가 중복해서 발생할 수 있다.**

언제 멱등성을 활용하는가?

→ DELETE와 같이 멱등성이 있는 메서드를 서버에 요청했는데 서버가 TIMEOUT 등으로 정상 응답을 못 주었을 때, 클라이언트가 같은 요청을 다시 해도 되는지에 대한 판단 근거로 사용함

GET을 100번 하는데 중간에 리소스가 변경되면 멱등이 깨지는거 아닌가?

⇒ 멱등은 외부 요인으로 중간에 리소스가 변경되는 것 까지는 고려하지 않는다.

<br>


### (3) 캐시가능 (Cacheable)

‘캐시가능’은 말 그대로 응답 결과 리소스를 캐시해서 사용해도 되는지를 의미한다.

이론적으로는 GET, HEAD, POST, PATCH는 캐시 가능하다.

하지만 실제로는 GET, HEAD 정도만 캐시로 사용한다.

→ POST, PATCH는 본문 내용까지 캐시 키로 고려해야 하는데, 구현이 쉽지 않기 때문이다.

<br>


# 4. HTTP 상태 코드

HTTP 상태 코드는 크게 다섯 가지로 나뉜다.

<br>

### (1) 100 ~ 100 : 정보성 상태 코드

- HTTP/1.1에서 도입됨
- 서버가 요청을 클라이언트에서 성공적으로 수신을 했고 서버에서 처리중인 정보를 보낸다

| 상태 코드 | 사유 구절 | 의미 |
| --- | --- | --- |
| 100 | Continue | 요청의 시작 부분 일부가 받아들여졌으며, 클라이언트는 나머지를 계속 이어서 보내야함 |
| 101 | Switching Protocols | 클라이언트가 Upgrade 헤더에 나열한 것 중 하나로 서버가 프로토콜을 바꾸었음을 의미함 |

<br>


### (2) 200~299 : 성공 상태 코드

- 서버가 요청을 성공적으로 받았음을 알려준다.

| 상태 코드 | 사유 구절 | 의미 |
| --- | --- | --- |
| 200 | Ok | 요청은 정상이고, 엔티티 본문은 요청된 리소스를 포함하고 있다. |
| 201 | Created | 요청한 객체가 생성되었음 |
| 202 | Accepted | 요청을 받아들여졌으나 서버는 아직 그에 대한 어떤 동작도 수행하지 않았다. |
| 203 | Non-authoriative Information | 엔터티 헤더에 들어있는 정보가 원래 서버가 아닌 리소스의 사본에서 왔다. 중개자가 리소스의 사본을 갖고 있었지만 리소스에 대한 메타 정보를 검증하지 못한 경우 이런 일이 발생할 수 있다. |
| 204 | No Content |  |

<br>


### (3) 300 ~ 399 : 리다이렉션 상태 코드

- 클라이언트가 관심있어 하는 리소스에 대한 다른 위치를 사용하라고 말해주거나 그 리소스의 내용 대신 다른 대안 응답을 제공한다.
- 리다이렉션 상태 코드와 선택적으로 Location 헤더를 보낼 수 있다.

| 상태 코드 | 사유 구절 | 의미 |
| --- | --- | --- |
| 301 | Multiple Choices | 클라이언트가 동시에 여러 리소스를 가리키는 URL을 요청한 경우, 그 리소스의 목록과 함께 반환한다. 사용자는 목록에서 원하는 하나를 선택할 수 있다. |
| 302 | Moved Permanently | 요청한 URL이 옮겨졌을 때 사용한다. 응답은 Location 헤더에 현재 리소스가 존재하고 있는 URL을 포함해야 한다. |
| 303 | Found | 301 상태 코드와 같다. 그러나 클라이언트는 Location 헤더로 주어진 URL을 리소소를 임시로 가리키기 위한 목적으로 사용해야 한다. 이후의 요청에서는 원래 URL을 사용해야 한다. |

<br>

### (4) 400 ~ 499 : 클라이언트 에러 상태 코드

- 클라이언트가 잘못 구성된 요청 메시지, 존재하지 않는 URL 등 서버가 다룰 수 없는 무엇인가를 보낼 때 발생한다.
- 클라이언트측에서 발생하는 코드이다.
- 많은 클라이언트 에러가 브라우저에 의해 처리된다.

| 상태 코드 |  사유 구절 | 의미 |
| --- | --- | --- |
| 400 | Bad Request | 클라이언트가 잘못된 요청을 보냄 |
| 401 | Unauthorized | 리소스를 얻기 전에 클라이언트에게 스스로를 인증하라고 요구하는 내용의 응답을 적절한 헤더와 함께 반환한다. |
| 403 | Forbidden | 요청이 서버에 의해 거부됨. 거부한 이유를 엔터티 본문에 포함시킬 수 있지만, 대부분 거절의 이유를 숨기고 싶을 때 사용함 |
| 404 | Not Found | 요청한 URL을 찾을 수 없음을 알려주기 위해 사용함 |
| 408 | Request Timeout | 클라이언트의 요청을 완수하기에 시간이 너무 많이 걸리는 경우, 서버는 이 상태 코드로 응답하고 연결을 끊을 수 있다. |

<br>

### (5) 500 ~ 599 : 서버 에러 상태 코드

- 클라이언트가 올바른 요청을 보냈음에도 서버가 처리하지 못하여 에러가 발생할 때 사용되는 코드이다.
- 클라이언트가 서버의 제한에 걸린 것일 수도 있고 혹은 게이트웨이 리소스와 같은 서버의 보조 구성요소에서 발생한 에러일 수도 있다.
- 서버측에서 발생하는 코드이다.

| 상태 코드 | 설명 | 의미 |
| --- | --- | --- |
| 500 | Internal Server Error | 서버가 요청을 처리할 수 없게 만드는 에러를 만났을 때 사용 |
| 501 | Not Implemented | 클라이언트가 서버의 능력을 넘은 요청을 했을대 사용한다. (서버가 지원하지 않는 메서드를 사용하는 경우 등) |
| 502 | Bad Gateway | 프락시나 게이트웨이처럼 행동하는 서버가 그 요청 응답 연쇄에 있는 다음 링크로부터 가짜 응답에 맞닥뜨렸을 때 사용한다. |
| 503 | Service Unavailable | 현재는 서버가 요청을 처리해 줄 수 없지만, 나중에는 가능함을 의미하고자 할 때 사용 |
| 504 | Gateway Timeout | 상태 코드 408과 비슷하지만, 다른 서버에게 요청을 보내고 응답을 기다리다 타임아웃이 발생한 게이트웨이나 프락시에서 온 응답이라는 점이 다르다. |
| 505 | HTTP Version Not Supported | 서버가 지원할 수 없거나 지원하지 않으려고 하는 버전의 프로토콜로 된 요청을 받았을 때 사용 |
