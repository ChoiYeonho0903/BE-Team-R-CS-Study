# 쿠키(Cookie), 세션(Session), JWT

## Cookie (쿠키)

### 1. 쿠키를 사용하는 이유

⇒  HTTP 프로토콜의 특징이자 약점을 보완하기 위해서 사용된다.

1. `Connectionless` (비연결성)
- 클라이언트가 서버에 요청(Request)을 했을 때, 그 요청에 맞는 응답(Response)을 보낸 후 연결을 끊는 처리방식
1. `Stateless` (무상태)
- 클라이언트의 상태 정보를 가지지 않는 서버 처리 방식
- 클라이언트와 첫번째 통신에서 데이터를 주고 받았다 해도, 두번째 통신에서 이전 데이터를 유지하지 않는다.

> 로그인 유지 등을 하기 위해 , Stateful 경우를 대처하기 위해서 쿠키와 세션을 사용한다.
>

### 2. 쿠키란?

<aside>
💡 쿠키는 **서버**가 **사용자의 웹 브라우저**에 전송하는 작은 데이터 조각이다.

</aside>

- 브라우저는 그 데이터 조각들을 저장해 놓았다가, 동일한 서버에 재요청 시 저장된 데이터를 함께 전송한다.

### 쿠키의 사용목적

1. 세션 관리 (Session Management)
- 로그인, 사용자 닉네임, 접속 시간, 장바구니 등의 서버가 알아야할 정보들을 저장
1. 개인화 (Personalization)
- 사용자마다 다르게 그 사람에 적절한 페이지를 보여줄 수 있다.
1. 트래킹 (Tracking)
- 사용자의 행동과 패턴을 분석하고 기록한다.
- ex) 최근 검색한 상품들을 광고에서 추천할 수 있다.

### Set-Cookie 그리고 Cookie 헤더

HTTP 요청을 수신할 때, 서버는 응답과 함께 `Set-Cookie` 헤더를 전송할 수 있다.

- 이 **서버** 헤더는 클라이언트에게 쿠키를 저장하라고 전달한다.

```
TTP/1.0 200 OK
Content-type: text/html
**Set-Cookie:** yummy_cookie=choco
**Set-Cookie:** tasty_cookie=strawberry
```

- 이제, 서버로 전송되는 모든 요청과 함께, **브라우저**는 Cookie 헤더를 사용하여 서버로 이전에 저장했던 모든 쿠키들을 회신한다.

```
GET /sample_page.html HTTP/1.1
Host: www.example.org
**Cookie:** yummy_cookie=choco; tasty_cookie=strawberry
```

### 쿠키의 속성

크롬 개발자 도구에서 쿠키를 볼 수 있으며 쿠키는 Name = Value 쌍으로 이루어져있고 여러 가지 속성에 대해서 살펴보겠다.

1. path
- 쿠키를 전송할 요청 경로
- url값으로 이 경로 혹은 하위의 경로에서만 쿠키에 접근할 수 있다.
- Example
  - path=/cat으로 설정하면 /cat, /cat/1, /cat/1/age에서 쿠키에 접근할 수 있다.
1. domain
- 쿠키를 전송할 도메인
- 쿠키에 접근 가능한 도메인을 설정
- Example
  - domain=google.com 설정
  - *.google.com과 같은 서브도메인에서도 쿠키에 접근할 수 있다.
1. expires와 max-age
- 쿠키의 기한 (만료 시점)을 설정
- expires 혹은 max-age가 설정되어 있지 않으면 브라우저를 닫을때 쿠키가 삭제되며 이를 “세션 쿠키”라고 한다.
- 설정한 기한이 되면 쿠키가 삭제
1. secure
- Secure는 HTTPS 프로토콜 상에서 암호화된 요청일 경우에만 전송된다.
1. httpOnly
- 클라이언트에서 document.cookie를 활용해 쿠키를 조작할 수 없도록 한다.
- XSS 공격을 방지하기 위해 사용된다.
- 예를 들어, 서버쪽에서 지속되고 있는 세션의 쿠키는 JavaScript를 사용할 필요성이 없기 때문에 HttpOnly 플래그가 설정될 것이다.
1. samesite
- CSRF(크로스 사이트 요청 위조)라 불리는 공격을 막기위해서 사용한다.
  - 즉, 사이트 외부에서의 쿠키에 대한 접근을 막는다.
- SameSite를 선언했을 경우 쿠키가 cross-site 요청시에 전송하지 않아 CSRF에 대해 방어할 수 있다.
  - SameSite의 기준 (도메인 비교)
    - 도메인 접미사와 도메인 접미사 바로 앞 도메인이 같다면 SameSite
    - [www.web.dev](http://www.web.dev) / static.web.dev는 “web.dev”라는 사이트의 일부로 SameSite이다.

> XSS (Cross-Site Scripting)
웹 사이트 관리자가 아닌 이가 웹 페이지에 악성 스크립트를 삽입할 수 있는 취약점이다.
>

![XSS](https://blog.kakaocdn.net/dn/JorZh/btrzvSNCKXp/ltObwAcweUSFT8nkToK8R1/img.gif)

> CSRF (Cross-Site Request Forgery)
사용자가 자신의 의지와는 무관하게 공격자가 의도한 행위를 특정 웹사이트에 요청하게 하는 공격을 말한다.
XSS를 이용한 공격이 사용자가 특정 웹사이트를 신용하는 점을 노린 것이라면 (공격대상 Client)
CSRF는 특정 웹사이트가 사용자의 웹 브라우저를 신용하는 상태를 노린 것이다. (공격대상 Server)
>

![CSRF](https://blog.kakaocdn.net/dn/bA3zK5/btrzveXVVNp/bKkKR447VyuVa7P60X5Xv1/img.png)

### 쿠키 종류

| 쿠키이름 | 특징 |
| --- | --- |
| Session Cookie | 메모리에만 저장되며 브라우저 종료시 쿠키를 삭제. |
| Persistent Cookie | 장기간 유지되는 쿠키(예를 들어 Max-Age 1년), 파일로 저장되어 브라우저 종료와 관계없이 사용 |
| Secure Cookie | HTTPS에서만 사용, 쿠키 정보가 암호화 되어 전송 |
| Third-Party Cookie | 방문한 도메인과 다른 도메인의 쿠키, 보통 광고 베너 등을 관리할 때 유입 경로를 추적하기 위해 사용. |
- Set-Cookie를 할때 Expires 속성이 존재하지 않으면 Session cookie로 간주하고 Expires 속성이 존재한다면 기간동아은 브라우저가 닫아도 사라지지 않는 persistent cookie로 간주한다.
- **퍼스트 파티 쿠키와 서드 파티 쿠키**
  ⇒ 설정된 도메인을 기준으로 퍼스트 파티 쿠키와 서드 파티 쿠키가 나뉘어 진다.
  - First party Cookie
    - 사용자가 방문한 웹사이트에서 직접 발행하는 쿠키 파일
  - Third part Cookie
    - 사용자가 방문한 웹사이트가 아닌, 다른 웹사이트에서 발행한 쿠키 파일

> Example
example.com 사이트 접속
사이트 페이지 속에 adserver.com의 스크립트가 심어져있다. (광고)
⇒ 이 때 adserver.com은 해당 사용자가 example.com이라는 사이트를 방문했다는 정보를 담은 쿠키를 발행 ⇒ 서드 파트 쿠키
>

![Cookie](https://blog.kakaocdn.net/dn/30fNH/btrzvcFWhOt/Wy4K6DCkOhbKWppfBk9Ckk/img.png)

⇒ tistory 접속 : tistory 첫번째 쿠키를 제외한 모든 쿠키는 서드 파트 쿠키

### 쿠키 단점

- 보안에 취약하다. 요청 시 쿠키 값을 그대로 보낸다.
  - CSRF : 사용자의 권한을 이용한 공격 (비밀번호 변경, 결제 요청)
  - XSS : 사용자의 민감한 정보 탈취(토큰)
- 작은 허용 용량 : 4096bytes (4KB) 이하
- 웹 브라우저 마다 지원 형태가 다르다.
- 문자열 그대로 통신하여 위변조가 가능하다.

## Session

<aside>
💡 일정시간 동안 같은 사용자로 부터 들어오는 일련의 요구를 하나의 상태로 보고 그 상태를 일정하게 유지시키는 기술

</aside>

- 중요한 정보를 클라이언트에 저장하는 쿠키와는 다르게 서버에 저장하여 관리하기 때문에 사용자 정보가 노출되지 않는다.
- 서버에서는 클라이언트를 구별하기 위해 각각의 세션ID를 클라이언트마다 부여하게 되며 클라이언트가 종료되기 전까지 유지한다.

### 서버(세션) 기반 인증

- 이전에 쿠키만을 사용하여 인증을 했을 경우에는 클라이언트에서 사용자 정보를 관리하여 보안에 매우 취약하다는 단점이 있다.
- 요즘에는 로그인과 같은 보안상 중요한 작업을 할 때는 세션을 사용한다.
- 예를 들어 사용자가 로그인을 하면, 세션에 사용자 정보를 저장해두고 서비스를 제공할 때 사용하곤 한다. 이러한 서버 기반의 시스템은 다음과 같은 흐름을 갖는다.

![서버 기반 인증](https://camo.githubusercontent.com/5717e7c7707d7c2aea846cf727ea3d0f4d2bee4b973ca2c0961ddb11156d6d56/68747470733a2f2f626c6f672e6b616b616f63646e2e6e65742f646e2f6265354846752f62747141735238694564682f726b39586e6f36586c5141776254574669474958496b2f696d672e706e67)

1. 사용자가 아이디와 비밀번호로 로그인을 한다.
2. 서버 측에서는 해당 정보를 검증한다.
3. 정보가 정확하다면 서버측에서 Set-Cookie를 통해 새로 발행한 sessionID를 보낸다.
4. 클라이언트 요청 시 마다 서버에 저장된 세션Id와 클라이언트에 있는 sessionID가 일치한지 확인한다.

이러한 인증 방식은 소규모 시스템에서는 아직 많이 사용되고 있지만, 웹/앱 어플리케이션이 발달하게 되면서 서버를 확장(Scale out)하기가 어렵다는 등 다음과 같은 문제점을 보이기 시작했다.

### 서버 기반 인증의 문제점

1. 서버 부하
- 세션 저장소가 필수적으로 존재하기 때문에 이를 사용하기 위한 비용이 든다.
- 서버에서 클라이언트의 상태를 모두 유지하고 있어야 하므로, 클라이언트 수에 따른 메모리나 디스크 또는 DB에 부하가 심하다.
1. 확장성 (Scale out이 어렵다)
- stateful 하기 때문에 http의 장점을 발휘하지 못하고 scale out에 걸림돌이 생긴다.
1. CORS
- 웹 브라우저에서 세션 관리에 사용하는 쿠키는 단일 도메인 및 서브 도메인에서만 작동하도록 설계되어 CORS 방식 (여러 도메인에 request를 보내는 브라우저)을 사용할 때 쿠키 및 세션 관리가 어렵다.

> CORS (Cross-Origin Resource Sharing, 교차 출처 리소스 공유)
HTTP 헤더를 사용하여, 한 출처에서 실행 중인 웹 애플리케이션이 다른 출처의 선택한 자원에 접근할 수 있는 권한을 부여하도록 브라우저에 알려주는 체제


## 토큰 기반 인증

토큰 기반 인증 시스템은 인증받은 사용자들에게 토큰을 발급하고, 서버에 요청을 할 때 헤더에 토큰을 함께 보내도록 하여 유효성 검사를 한다. 이러한 시스템에서는 더이상 사용자의 인증 정보를 서버나 세션에 유지하지 않고 클라이언트 측에서 들어오는 요청만으로 작업을 처리한다.

즉, 서버 기반의 인증 시스템과 달리 상태를 유지하지 않으므로 stateless한 구조를 갖는다.

![토큰 기반 인증](https://camo.githubusercontent.com/2fe1b886df7b6ae69e30d4c80d86871dafcd50ee2b02c09f41b9b1bb7270f2b0/68747470733a2f2f626c6f672e6b616b616f63646e2e6e65742f646e2f6f676f41672f62747141726979543573592f59597432776b457a35306b4b4e34376d4c775244584b2f696d672e706e67)

1. 사용자가 아이디와 비밀번호로 로그인을 한다.
2. 서버 측에서는 해당 정보를 검증한다.
3. 정보가 정확하다면 서버측에서 사용자에게 토큰을 발급한다.
4. 클라이언트 측에서 전달받은 토큰을 저장해두고, 서버에 요청을 할 때마다 해당 토큰을 서버에 함께 전달한다.
5. 서버는 토큰을 검증하고, 요청에 응답한다.

### 토큰 기반 인증 시스템의 이점

1. 무상태성 & 확장성

토큰은 클라이언트 측에 저장되기 때문에 서버는 완전히 Stateless하며, 클라이언트와 서버의 연결고리가 없기 때문에 확장하기에 매우 적합하다.

1. 여러 플랫폼 및 도메인
- 서버 기반 인증 시스템의 문제점 중 하나인 CORS를 해결할 수 있다. 토큰을 사용한다면 어떤 디바이스, 어떤 도메인에서도 토큰의 유효성 검사를 진행한 후에 요청을 처리할 수 있다.

최근에는 Json 포맷을 이용하는 JWT(Json Web Token)을 주로 사용한다.

## JWT (Json Web Token)

<aside>
💡 JWT이란 인증에 필요한 정보들을 Token에 담아 암호화 시킨 토큰을 의미한다.

</aside>

![JWT](https://blog.kakaocdn.net/dn/6z8H7/btrzuZmpULk/D3ocLNCelLFFbNAeaxQ4sk/img.png)

### JWT 구조

JWT는 Header, Payload, Signature 3부분으로 이루어지며, Json 형태인 각 부분은 Base64로 인코딩 되어 있다.

또한 각각 부분을 이어주기

1. Header

⇒  header에는 보통 토큰의 타입이나, 서명 생성에 어떤 알고리즘이 사용되었는지 저장

![JWT_HEADER](https://camo.githubusercontent.com/e48e47ff1f980a9268523fdfde36fcdd6481f6754cc12abecbfd819d2f90e9f6/68747470733a2f2f7465636f626c652e74656368636f757273652e636f2e6b722f7374617469632f65373934626433626333656361383332333530626437333033313863356562622f66373838362f323032312d30352d32322d6a77742d6865616465722e706e67)

- 토큰의 타입 : “JWT”
- 알고리즘 : “HS512”

1. Payload

![JWT_Payload](https://camo.githubusercontent.com/9f54e33e43b71c045ff113134708c0a098802c7a281605ddd2d78328333e238f/68747470733a2f2f7465636f626c652e74656368636f757273652e636f2e6b722f7374617469632f35326663376532316535626132376161313633346361323638333637383563652f31653761392f323032312d30352d32322d6a77742d7061796c6f61642e706e67)

- Payload는 **토큰에 담을 정보**를 지니고 있다. Key-value 형식으로 이루어진 한 쌍의 정보를 Claim이라고 칭한다.
- payload에 민감한 정보를 담지 않는다.
    - header, payload는 json이 디코딩되어있을 뿐이지 특별한 암호화가 걸려있는 것이 아니기 때문에 누구나 jwt를 가지고 디코딩을 한다면 header나 payload에 담긴 값을 알 수 있다.

1. Signature

⇒ 토큰을 인코딩하거나 유효성 검증을 할 때 사용되는 고유한 암호화 코드

![JWT_Signature](https://camo.githubusercontent.com/117eb2bf272887add87d79d5775e621a30409c6641e6fedefac9ab24c26fd909/68747470733a2f2f7465636f626c652e74656368636f757273652e636f2e6b722f7374617469632f34343562393931366137646434663137623936383265663335333435373438342f63346266372f323032312d30352d32322d6a77742d7369676e61747572652e706e67)

- signature는 인코딩된 Heade와 Payload를 더한 뒤 비밀키로 해싱하여 생성한다.
- Signature는 서버 측에서 관리하는 비밀키가 유출되지 않는 이상 복호화 할 수 없다.
- 따라서 Signature는 토큰의 위변조 여부를 확인하는데 사용한다.

### 장점

- Header와 Payload를 가지고 Signature를 생성하므로 데이터 위변조를 막을 수 있다. (보완성 증가)
- 세션과 다르게 클라이언트의 상태를 서버가 저장해 두지 않는다.

### 단점

- 쿠키/세션과 다르게 JWT는 토큰의 길이가 길어, 인증 요청이 많아질수록 네트워크 부하가 심해진다.
- Payload 자체는 암호화 되지 않기 때문에 유저의 중요한 정보는 담을 수 없다.
- 토큰은 한번 발급 되면 유효기간이 만료될 때 까지 계속 사용되어 탈취 당하게 되면 대처하기 힘들다. ⇒ 크리티컬한 문제
    - 만료시간을 짧게 가져가자

### 짧은 JWT 유효시간을 보완하는 방법

1. Sliding Session
- 특정한 서비스를 계속 사용하고 있는 특정 유저에 대해 만료 시간을 연장시켜주는 방법
1. Refresh Token ⇒ 가장 많이 사용
- JWT를 처음 발급할 때 Access Token과 함께 Refresh Token이라는 토큰을 발급한다.
- 비교적 긴 시간 (7일, 30일 등)의 만료시간을 가진 Refresh Token은 Access Token을 Refresh 해주는 것을 보장하는 토큰
    - Access Token이 만료되었다면 Refresh Token으로 서버에게 새로운 Access Token을 발급받는다.

## 예상 질문

### 쿠키와 세션을 사용하는 이유

- HTTP 프로토콜의 특성이자 약점을 보완하기 위해서 사용한다.
- connectionless, stateless 특성을 가지기 때문에 서버는 클라이언트가 누구인지 매번 확인해야 한다. 이 특성을 보완하기 위해서 쿠키와 세션을 사용하게 된다.

### 쿠키와 세션의 차이

- 저장위치
    - 쿠키는 클라이언트에 파일로 저장
    - 세션은 서버에 저장
- 보안
    - 쿠키는 보안에 취약
    - 세션은 쿠키를 이용해서 세션id만 클라이언트에 저장하기때문에 보안성이 높다.

### 쿠키와 웹스토리지

- 클라이언트(브라우저)에 데이터를 저장할 수 있도록 HTML5부터 새롭게 지원하는 저장소
    - 쿠키의 단점을 보완해 기술 탄생
    - 웹스토리지는 로컬에만 정보를 저장, 쿠키는 서버와 로컬에 정보를 저장
- 웹 스토리지는 단순 문자열을 넘어서 객체 정보 저장이 가능하다.
- 5MB까지 저장 공간을 이용할 수 있다. (쿠키 4KB)
- 쿠키와 달리, 서버에 전송되지 않으므로 서버에 부담이 가지 않는다.
- 필요한 경우에만 꺼내 쓰는 것이므로 자동 전송의 위험성이 없다.
- 다른 도메인에서 요청하는 경우에는, 꺼내 쓰고 싶어도 도메인 단위로 접근이 제한되는 특성 덕분에 값을 꺼내 쓸 수 없다. (CSRF 안전)
- 단점
    - HTML5를 지원하지 않는 브라우저에서는 사용할 수 없다.

데이터의 라이프 사이클에 따라 나뉜다.

- 로컬 스토리지
    - 브라우저를 종료해도 유지되는 데이터로, 명시적으로 지우지 않는 한 영구적으로 저장
    - **도메인 별, 브라우저 별** 독립된 스토리지 사용
    - 따라서 다른 웹사이트에 들어간다면 로컬 스토리지가 동일하지 않다.
- 세션 스토리지
    - 탭별로 다른 스토리지를 사용한다.
    - 탭 종료 or 브라우저 종료시 삭제된다.

- 자동 로그인 → 로컬스토리지
- 입력 폼 정보 → 세션스토리지
- 비로그인 장바구니 → 세션스토리지

## Reference

[https://github.com/NKLCWDT/cs/blob/main/Network/Cookie%2C Session%2C JWT.md](https://github.com/NKLCWDT/cs/blob/main/Network/Cookie%2C%20Session%2C%20JWT.md)

[https://program-developer.tistory.com/99](https://program-developer.tistory.com/99)

[https://brunch.co.kr/@jinyoungchoi95/1](https://brunch.co.kr/@jinyoungchoi95/1)